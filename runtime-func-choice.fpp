#! fypp example of selecting function at runtime, but having the function be compile time inlined.
#! really, you already have the permutations of possible function choices compiled and inlined, 
#! you just select which one to use are runtime.
#! example usage: fypp mymodule.fpp mymodule.f90

#! Remember, python ranges are strictly less than, unlike fortran
#:set irange = range(0,2)
! note, you could use strings instead of integers--anything that python allows. 

module mymodule

contains

  subroutine foo(i) 
    implicit none
    ! i is passed in at runtime. If i is 0, we want foo_kernel to use bar0, if 1 use bar1
    integer,intent(in) :: i 
    select case(i)
    #:for i in irange
       case(${i}$)
          call foo_bar${i}$()
    #:endfor
       end select

  end subroutine foo

  ! In the function below, the choice of i is compile time constant inside the routine.
  ! You could just call bar${i}() without the branching logic below.

  
#:for i in irange
  subroutine foo_bar${i}$()
    implicit none
    call bar${i}$()

  end subroutine foo_bar${i}$
  
#:endfor

  
  ! However, the function below has case statements (which are autogenerated) below to show you how
  ! you could keep your same branching logic inside your current function body (which becomes the body of the below function). 
  ! Since the compiler will eliminate dead branches, you only get one branch choice per instance of foo_bar.

  
#:for i in irange
  subroutine foo_bar${i}$()
    implicit none
    integer, parameter :: i=${i}$
    select case(i) 
    #:for i in irange
       case(${i}$)
          call bar${i}$()
    #:endfor
       end select       

  end subroutine foo_bar${i}$
     
#:endfor
  

end module mymodule
